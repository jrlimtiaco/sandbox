// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class CreatorshipTransfer extends ethereum.Event {
  get params(): CreatorshipTransfer__Params {
    return new CreatorshipTransfer__Params(this);
  }
}

export class CreatorshipTransfer__Params {
  _event: CreatorshipTransfer;

  constructor(event: CreatorshipTransfer) {
    this._event = event;
  }

  get original(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class BouncerAdminChanged extends ethereum.Event {
  get params(): BouncerAdminChanged__Params {
    return new BouncerAdminChanged__Params(this);
  }
}

export class BouncerAdminChanged__Params {
  _event: BouncerAdminChanged;

  constructor(event: BouncerAdminChanged) {
    this._event = event;
  }

  get oldBouncerAdmin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newBouncerAdmin(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Bouncer extends ethereum.Event {
  get params(): Bouncer__Params {
    return new Bouncer__Params(this);
  }
}

export class Bouncer__Params {
  _event: Bouncer;

  constructor(event: Bouncer) {
    this._event = event;
  }

  get bouncer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class MetaTransactionProcessor extends ethereum.Event {
  get params(): MetaTransactionProcessor__Params {
    return new MetaTransactionProcessor__Params(this);
  }
}

export class MetaTransactionProcessor__Params {
  _event: MetaTransactionProcessor;

  constructor(event: MetaTransactionProcessor) {
    this._event = event;
  }

  get metaTransactionProcessor(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class Extraction extends ethereum.Event {
  get params(): Extraction__Params {
    return new Extraction__Params(this);
  }
}

export class Extraction__Params {
  _event: Extraction;

  constructor(event: Extraction) {
    this._event = event;
  }

  get fromId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get toId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class AssetUpdate extends ethereum.Event {
  get params(): AssetUpdate__Params {
    return new AssetUpdate__Params(this);
  }
}

export class AssetUpdate__Params {
  _event: AssetUpdate;

  constructor(event: AssetUpdate) {
    this._event = event;
  }

  get fromId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get toId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get _owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _approved(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this);
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll;

  constructor(event: ApprovalForAll) {
    this._event = event;
  }

  get _owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get _operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get _approved(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class TransferSingle extends ethereum.Event {
  get params(): TransferSingle__Params {
    return new TransferSingle__Params(this);
  }
}

export class TransferSingle__Params {
  _event: TransferSingle;

  constructor(event: TransferSingle) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get id(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get value(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class TransferBatch extends ethereum.Event {
  get params(): TransferBatch__Params {
    return new TransferBatch__Params(this);
  }
}

export class TransferBatch__Params {
  _event: TransferBatch;

  constructor(event: TransferBatch) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get ids(): Array<BigInt> {
    return this._event.parameters[3].value.toBigIntArray();
  }

  get values(): Array<BigInt> {
    return this._event.parameters[4].value.toBigIntArray();
  }
}

export class URI extends ethereum.Event {
  get params(): URI__Params {
    return new URI__Params(this);
  }
}

export class URI__Params {
  _event: URI;

  constructor(event: URI) {
    this._event = event;
  }

  get value(): string {
    return this._event.parameters[0].value.toString();
  }

  get id(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class SuperOperator extends ethereum.Event {
  get params(): SuperOperator__Params {
    return new SuperOperator__Params(this);
  }
}

export class SuperOperator__Params {
  _event: SuperOperator;

  constructor(event: SuperOperator) {
    this._event = event;
  }

  get superOperator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class AdminChanged extends ethereum.Event {
  get params(): AdminChanged__Params {
    return new AdminChanged__Params(this);
  }
}

export class AdminChanged__Params {
  _event: AdminChanged;

  constructor(event: AdminChanged) {
    this._event = event;
  }

  get oldAdmin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newAdmin(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Asset extends ethereum.SmartContract {
  static bind(address: Address): Asset {
    return new Asset("Asset", address);
  }

  balanceOf(owner: Address, id: BigInt): BigInt {
    let result = super.call(
      "balanceOf",
      "balanceOf(address,uint256):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromUnsignedBigInt(id)]
    );

    return result[0].toBigInt();
  }

  try_balanceOf(owner: Address, id: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceOf",
      "balanceOf(address,uint256):(uint256)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  supportsInterface(id: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(id)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(id: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  getApproved(id: BigInt): Address {
    let result = super.call("getApproved", "getApproved(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toAddress();
  }

  try_getApproved(id: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getApproved",
      "getApproved(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  uri(id: BigInt): string {
    let result = super.call("uri", "uri(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toString();
  }

  try_uri(id: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("uri", "uri(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  collectionIndexOf(id: BigInt): BigInt {
    let result = super.call(
      "collectionIndexOf",
      "collectionIndexOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );

    return result[0].toBigInt();
  }

  try_collectionIndexOf(id: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "collectionIndexOf",
      "collectionIndexOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  extractERC721(id: BigInt, to: Address): BigInt {
    let result = super.call(
      "extractERC721",
      "extractERC721(uint256,address):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(id), ethereum.Value.fromAddress(to)]
    );

    return result[0].toBigInt();
  }

  try_extractERC721(id: BigInt, to: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "extractERC721",
      "extractERC721(uint256,address):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(id), ethereum.Value.fromAddress(to)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isBouncer(who: Address): boolean {
    let result = super.call("isBouncer", "isBouncer(address):(bool)", [
      ethereum.Value.fromAddress(who)
    ]);

    return result[0].toBoolean();
  }

  try_isBouncer(who: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isBouncer", "isBouncer(address):(bool)", [
      ethereum.Value.fromAddress(who)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  balanceOfBatch(owners: Array<Address>, ids: Array<BigInt>): Array<BigInt> {
    let result = super.call(
      "balanceOfBatch",
      "balanceOfBatch(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(owners),
        ethereum.Value.fromUnsignedBigIntArray(ids)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_balanceOfBatch(
    owners: Array<Address>,
    ids: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "balanceOfBatch",
      "balanceOfBatch(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(owners),
        ethereum.Value.fromUnsignedBigIntArray(ids)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  creatorOf(id: BigInt): Address {
    let result = super.call("creatorOf", "creatorOf(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toAddress();
  }

  try_creatorOf(id: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("creatorOf", "creatorOf(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  ownerOf(id: BigInt): Address {
    let result = super.call("ownerOf", "ownerOf(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toAddress();
  }

  try_ownerOf(id: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("ownerOf", "ownerOf(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isSuperOperator(who: Address): boolean {
    let result = super.call(
      "isSuperOperator",
      "isSuperOperator(address):(bool)",
      [ethereum.Value.fromAddress(who)]
    );

    return result[0].toBoolean();
  }

  try_isSuperOperator(who: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isSuperOperator",
      "isSuperOperator(address):(bool)",
      [ethereum.Value.fromAddress(who)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getAdmin(): Address {
    let result = super.call("getAdmin", "getAdmin():(address)", []);

    return result[0].toAddress();
  }

  try_getAdmin(): ethereum.CallResult<Address> {
    let result = super.tryCall("getAdmin", "getAdmin():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  balanceOf1(owner: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf1(owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  rarity(id: BigInt): BigInt {
    let result = super.call("rarity", "rarity(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBigInt();
  }

  try_rarity(id: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("rarity", "rarity(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isPackIdUsed(creator: Address, packId: BigInt, numFTs: i32): boolean {
    let result = super.call(
      "isPackIdUsed",
      "isPackIdUsed(address,uint40,uint16):(bool)",
      [
        ethereum.Value.fromAddress(creator),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(numFTs))
      ]
    );

    return result[0].toBoolean();
  }

  try_isPackIdUsed(
    creator: Address,
    packId: BigInt,
    numFTs: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isPackIdUsed",
      "isPackIdUsed(address,uint40,uint16):(bool)",
      [
        ethereum.Value.fromAddress(creator),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(numFTs))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  getBouncerAdmin(): Address {
    let result = super.call(
      "getBouncerAdmin",
      "getBouncerAdmin():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getBouncerAdmin(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getBouncerAdmin",
      "getBouncerAdmin():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isCollection(id: BigInt): boolean {
    let result = super.call("isCollection", "isCollection(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_isCollection(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("isCollection", "isCollection(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  mint(
    creator: Address,
    packId: BigInt,
    hash: Bytes,
    supply: BigInt,
    rarity: i32,
    owner: Address,
    data: Bytes
  ): BigInt {
    let result = super.call(
      "mint",
      "mint(address,uint40,bytes32,uint256,uint8,address,bytes):(uint256)",
      [
        ethereum.Value.fromAddress(creator),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromUnsignedBigInt(supply),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(rarity)),
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBigInt();
  }

  try_mint(
    creator: Address,
    packId: BigInt,
    hash: Bytes,
    supply: BigInt,
    rarity: i32,
    owner: Address,
    data: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "mint",
      "mint(address,uint40,bytes32,uint256,uint8,address,bytes):(uint256)",
      [
        ethereum.Value.fromAddress(creator),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromUnsignedBigInt(supply),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(rarity)),
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  collectionOf(id: BigInt): BigInt {
    let result = super.call("collectionOf", "collectionOf(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBigInt();
  }

  try_collectionOf(id: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "collectionOf",
      "collectionOf(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenURI(id: BigInt): string {
    let result = super.call("tokenURI", "tokenURI(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toString();
  }

  try_tokenURI(id: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("tokenURI", "tokenURI(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  wasEverMinted(id: BigInt): boolean {
    let result = super.call("wasEverMinted", "wasEverMinted(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_wasEverMinted(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "wasEverMinted",
      "wasEverMinted(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isMetaTransactionProcessor(who: Address): boolean {
    let result = super.call(
      "isMetaTransactionProcessor",
      "isMetaTransactionProcessor(address):(bool)",
      [ethereum.Value.fromAddress(who)]
    );

    return result[0].toBoolean();
  }

  try_isMetaTransactionProcessor(who: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isMetaTransactionProcessor",
      "isMetaTransactionProcessor(address):(bool)",
      [ethereum.Value.fromAddress(who)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isApprovedForAll(owner: Address, operator: Address): boolean {
    let result = super.call(
      "isApprovedForAll",
      "isApprovedForAll(address,address):(bool)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(operator)]
    );

    return result[0].toBoolean();
  }

  try_isApprovedForAll(
    owner: Address,
    operator: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isApprovedForAll",
      "isApprovedForAll(address,address):(bool)",
      [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(operator)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  updateERC721(
    from: Address,
    id: BigInt,
    packId: BigInt,
    hash: Bytes,
    newRarity: i32,
    to: Address,
    data: Bytes
  ): BigInt {
    let result = super.call(
      "updateERC721",
      "updateERC721(address,uint256,uint40,bytes32,uint8,address,bytes):(uint256)",
      [
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigInt(id),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(newRarity)),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBigInt();
  }

  try_updateERC721(
    from: Address,
    id: BigInt,
    packId: BigInt,
    hash: Bytes,
    newRarity: i32,
    to: Address,
    data: Bytes
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "updateERC721",
      "updateERC721(address,uint256,uint40,bytes32,uint8,address,bytes):(uint256)",
      [
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromUnsignedBigInt(id),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(newRarity)),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  mintMultiple(
    creator: Address,
    packId: BigInt,
    hash: Bytes,
    supplies: Array<BigInt>,
    rarityPack: Bytes,
    owner: Address,
    data: Bytes
  ): Array<BigInt> {
    let result = super.call(
      "mintMultiple",
      "mintMultiple(address,uint40,bytes32,uint256[],bytes,address,bytes):(uint256[])",
      [
        ethereum.Value.fromAddress(creator),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromUnsignedBigIntArray(supplies),
        ethereum.Value.fromBytes(rarityPack),
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromBytes(data)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_mintMultiple(
    creator: Address,
    packId: BigInt,
    hash: Bytes,
    supplies: Array<BigInt>,
    rarityPack: Bytes,
    owner: Address,
    data: Bytes
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "mintMultiple",
      "mintMultiple(address,uint40,bytes32,uint256[],bytes,address,bytes):(uint256[])",
      [
        ethereum.Value.fromAddress(creator),
        ethereum.Value.fromUnsignedBigInt(packId),
        ethereum.Value.fromFixedBytes(hash),
        ethereum.Value.fromUnsignedBigIntArray(supplies),
        ethereum.Value.fromBytes(rarityPack),
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  extractERC721From(sender: Address, id: BigInt, to: Address): BigInt {
    let result = super.call(
      "extractERC721From",
      "extractERC721From(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromUnsignedBigInt(id),
        ethereum.Value.fromAddress(to)
      ]
    );

    return result[0].toBigInt();
  }

  try_extractERC721From(
    sender: Address,
    id: BigInt,
    to: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "extractERC721From",
      "extractERC721From(address,uint256,address):(uint256)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromUnsignedBigInt(id),
        ethereum.Value.fromAddress(to)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ChangeBouncerAdminCall extends ethereum.Call {
  get inputs(): ChangeBouncerAdminCall__Inputs {
    return new ChangeBouncerAdminCall__Inputs(this);
  }

  get outputs(): ChangeBouncerAdminCall__Outputs {
    return new ChangeBouncerAdminCall__Outputs(this);
  }
}

export class ChangeBouncerAdminCall__Inputs {
  _call: ChangeBouncerAdminCall;

  constructor(call: ChangeBouncerAdminCall) {
    this._call = call;
  }

  get newBouncerAdmin(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ChangeBouncerAdminCall__Outputs {
  _call: ChangeBouncerAdminCall;

  constructor(call: ChangeBouncerAdminCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }
}

export class BurnFromCall extends ethereum.Call {
  get inputs(): BurnFromCall__Inputs {
    return new BurnFromCall__Inputs(this);
  }

  get outputs(): BurnFromCall__Outputs {
    return new BurnFromCall__Outputs(this);
  }
}

export class BurnFromCall__Inputs {
  _call: BurnFromCall;

  constructor(call: BurnFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class BurnFromCall__Outputs {
  _call: BurnFromCall;

  constructor(call: BurnFromCall) {
    this._call = call;
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }
}

export class ApproveForCall extends ethereum.Call {
  get inputs(): ApproveForCall__Inputs {
    return new ApproveForCall__Inputs(this);
  }

  get outputs(): ApproveForCall__Outputs {
    return new ApproveForCall__Outputs(this);
  }
}

export class ApproveForCall__Inputs {
  _call: ApproveForCall;

  constructor(call: ApproveForCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get operator(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ApproveForCall__Outputs {
  _call: ApproveForCall;

  constructor(call: ApproveForCall) {
    this._call = call;
  }
}

export class SafeBatchTransferFromCall extends ethereum.Call {
  get inputs(): SafeBatchTransferFromCall__Inputs {
    return new SafeBatchTransferFromCall__Inputs(this);
  }

  get outputs(): SafeBatchTransferFromCall__Outputs {
    return new SafeBatchTransferFromCall__Outputs(this);
  }
}

export class SafeBatchTransferFromCall__Inputs {
  _call: SafeBatchTransferFromCall;

  constructor(call: SafeBatchTransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }

  get values(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class SafeBatchTransferFromCall__Outputs {
  _call: SafeBatchTransferFromCall;

  constructor(call: SafeBatchTransferFromCall) {
    this._call = call;
  }
}

export class SafeTransferFromCall extends ethereum.Call {
  get inputs(): SafeTransferFromCall__Inputs {
    return new SafeTransferFromCall__Inputs(this);
  }

  get outputs(): SafeTransferFromCall__Outputs {
    return new SafeTransferFromCall__Outputs(this);
  }
}

export class SafeTransferFromCall__Inputs {
  _call: SafeTransferFromCall;

  constructor(call: SafeTransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SafeTransferFromCall__Outputs {
  _call: SafeTransferFromCall;

  constructor(call: SafeTransferFromCall) {
    this._call = call;
  }
}

export class ExtractERC721Call extends ethereum.Call {
  get inputs(): ExtractERC721Call__Inputs {
    return new ExtractERC721Call__Inputs(this);
  }

  get outputs(): ExtractERC721Call__Outputs {
    return new ExtractERC721Call__Outputs(this);
  }
}

export class ExtractERC721Call__Inputs {
  _call: ExtractERC721Call;

  constructor(call: ExtractERC721Call) {
    this._call = call;
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class ExtractERC721Call__Outputs {
  _call: ExtractERC721Call;

  constructor(call: ExtractERC721Call) {
    this._call = call;
  }

  get newId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetMetaTransactionProcessorCall extends ethereum.Call {
  get inputs(): SetMetaTransactionProcessorCall__Inputs {
    return new SetMetaTransactionProcessorCall__Inputs(this);
  }

  get outputs(): SetMetaTransactionProcessorCall__Outputs {
    return new SetMetaTransactionProcessorCall__Outputs(this);
  }
}

export class SetMetaTransactionProcessorCall__Inputs {
  _call: SetMetaTransactionProcessorCall;

  constructor(call: SetMetaTransactionProcessorCall) {
    this._call = call;
  }

  get metaTransactionProcessor(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetMetaTransactionProcessorCall__Outputs {
  _call: SetMetaTransactionProcessorCall;

  constructor(call: SetMetaTransactionProcessorCall) {
    this._call = call;
  }
}

export class ChangeAdminCall extends ethereum.Call {
  get inputs(): ChangeAdminCall__Inputs {
    return new ChangeAdminCall__Inputs(this);
  }

  get outputs(): ChangeAdminCall__Outputs {
    return new ChangeAdminCall__Outputs(this);
  }
}

export class ChangeAdminCall__Inputs {
  _call: ChangeAdminCall;

  constructor(call: ChangeAdminCall) {
    this._call = call;
  }

  get newAdmin(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ChangeAdminCall__Outputs {
  _call: ChangeAdminCall;

  constructor(call: ChangeAdminCall) {
    this._call = call;
  }
}

export class IsPackIdUsedCall extends ethereum.Call {
  get inputs(): IsPackIdUsedCall__Inputs {
    return new IsPackIdUsedCall__Inputs(this);
  }

  get outputs(): IsPackIdUsedCall__Outputs {
    return new IsPackIdUsedCall__Outputs(this);
  }
}

export class IsPackIdUsedCall__Inputs {
  _call: IsPackIdUsedCall;

  constructor(call: IsPackIdUsedCall) {
    this._call = call;
  }

  get creator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get packId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get numFTs(): i32 {
    return this._call.inputValues[2].value.toI32();
  }
}

export class IsPackIdUsedCall__Outputs {
  _call: IsPackIdUsedCall;

  constructor(call: IsPackIdUsedCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class SetApprovalForAllCall extends ethereum.Call {
  get inputs(): SetApprovalForAllCall__Inputs {
    return new SetApprovalForAllCall__Inputs(this);
  }

  get outputs(): SetApprovalForAllCall__Outputs {
    return new SetApprovalForAllCall__Outputs(this);
  }
}

export class SetApprovalForAllCall__Inputs {
  _call: SetApprovalForAllCall;

  constructor(call: SetApprovalForAllCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get approved(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetApprovalForAllCall__Outputs {
  _call: SetApprovalForAllCall;

  constructor(call: SetApprovalForAllCall) {
    this._call = call;
  }
}

export class SetSuperOperatorCall extends ethereum.Call {
  get inputs(): SetSuperOperatorCall__Inputs {
    return new SetSuperOperatorCall__Inputs(this);
  }

  get outputs(): SetSuperOperatorCall__Outputs {
    return new SetSuperOperatorCall__Outputs(this);
  }
}

export class SetSuperOperatorCall__Inputs {
  _call: SetSuperOperatorCall;

  constructor(call: SetSuperOperatorCall) {
    this._call = call;
  }

  get superOperator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetSuperOperatorCall__Outputs {
  _call: SetSuperOperatorCall;

  constructor(call: SetSuperOperatorCall) {
    this._call = call;
  }
}

export class BurnCall extends ethereum.Call {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this);
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this);
  }
}

export class BurnCall__Inputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class BurnCall__Outputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }
}

export class TransferCreatorshipCall extends ethereum.Call {
  get inputs(): TransferCreatorshipCall__Inputs {
    return new TransferCreatorshipCall__Inputs(this);
  }

  get outputs(): TransferCreatorshipCall__Outputs {
    return new TransferCreatorshipCall__Outputs(this);
  }
}

export class TransferCreatorshipCall__Inputs {
  _call: TransferCreatorshipCall;

  constructor(call: TransferCreatorshipCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get original(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class TransferCreatorshipCall__Outputs {
  _call: TransferCreatorshipCall;

  constructor(call: TransferCreatorshipCall) {
    this._call = call;
  }
}

export class SafeTransferFrom1Call extends ethereum.Call {
  get inputs(): SafeTransferFrom1Call__Inputs {
    return new SafeTransferFrom1Call__Inputs(this);
  }

  get outputs(): SafeTransferFrom1Call__Outputs {
    return new SafeTransferFrom1Call__Outputs(this);
  }
}

export class SafeTransferFrom1Call__Inputs {
  _call: SafeTransferFrom1Call;

  constructor(call: SafeTransferFrom1Call) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class SafeTransferFrom1Call__Outputs {
  _call: SafeTransferFrom1Call;

  constructor(call: SafeTransferFrom1Call) {
    this._call = call;
  }
}

export class SetBouncerCall extends ethereum.Call {
  get inputs(): SetBouncerCall__Inputs {
    return new SetBouncerCall__Inputs(this);
  }

  get outputs(): SetBouncerCall__Outputs {
    return new SetBouncerCall__Outputs(this);
  }
}

export class SetBouncerCall__Inputs {
  _call: SetBouncerCall;

  constructor(call: SetBouncerCall) {
    this._call = call;
  }

  get bouncer(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get enabled(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetBouncerCall__Outputs {
  _call: SetBouncerCall;

  constructor(call: SetBouncerCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get creator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get packId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get hash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get supply(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get rarity(): i32 {
    return this._call.inputValues[4].value.toI32();
  }

  get owner(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get data(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get id(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class UpdateERC721Call extends ethereum.Call {
  get inputs(): UpdateERC721Call__Inputs {
    return new UpdateERC721Call__Inputs(this);
  }

  get outputs(): UpdateERC721Call__Outputs {
    return new UpdateERC721Call__Outputs(this);
  }
}

export class UpdateERC721Call__Inputs {
  _call: UpdateERC721Call;

  constructor(call: UpdateERC721Call) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get packId(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get hash(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get newRarity(): i32 {
    return this._call.inputValues[4].value.toI32();
  }

  get to(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get data(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }
}

export class UpdateERC721Call__Outputs {
  _call: UpdateERC721Call;

  constructor(call: UpdateERC721Call) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SetApprovalForAllForCall extends ethereum.Call {
  get inputs(): SetApprovalForAllForCall__Inputs {
    return new SetApprovalForAllForCall__Inputs(this);
  }

  get outputs(): SetApprovalForAllForCall__Outputs {
    return new SetApprovalForAllForCall__Outputs(this);
  }
}

export class SetApprovalForAllForCall__Inputs {
  _call: SetApprovalForAllForCall;

  constructor(call: SetApprovalForAllForCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get operator(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get approved(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class SetApprovalForAllForCall__Outputs {
  _call: SetApprovalForAllForCall;

  constructor(call: SetApprovalForAllForCall) {
    this._call = call;
  }
}

export class MintMultipleCall extends ethereum.Call {
  get inputs(): MintMultipleCall__Inputs {
    return new MintMultipleCall__Inputs(this);
  }

  get outputs(): MintMultipleCall__Outputs {
    return new MintMultipleCall__Outputs(this);
  }
}

export class MintMultipleCall__Inputs {
  _call: MintMultipleCall;

  constructor(call: MintMultipleCall) {
    this._call = call;
  }

  get creator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get packId(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get hash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get supplies(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get rarityPack(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get owner(): Address {
    return this._call.inputValues[5].value.toAddress();
  }

  get data(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }
}

export class MintMultipleCall__Outputs {
  _call: MintMultipleCall;

  constructor(call: MintMultipleCall) {
    this._call = call;
  }

  get ids(): Array<BigInt> {
    return this._call.outputValues[0].value.toBigIntArray();
  }
}

export class SafeTransferFrom2Call extends ethereum.Call {
  get inputs(): SafeTransferFrom2Call__Inputs {
    return new SafeTransferFrom2Call__Inputs(this);
  }

  get outputs(): SafeTransferFrom2Call__Outputs {
    return new SafeTransferFrom2Call__Outputs(this);
  }
}

export class SafeTransferFrom2Call__Inputs {
  _call: SafeTransferFrom2Call;

  constructor(call: SafeTransferFrom2Call) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get value(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class SafeTransferFrom2Call__Outputs {
  _call: SafeTransferFrom2Call;

  constructor(call: SafeTransferFrom2Call) {
    this._call = call;
  }
}

export class ExtractERC721FromCall extends ethereum.Call {
  get inputs(): ExtractERC721FromCall__Inputs {
    return new ExtractERC721FromCall__Inputs(this);
  }

  get outputs(): ExtractERC721FromCall__Outputs {
    return new ExtractERC721FromCall__Outputs(this);
  }
}

export class ExtractERC721FromCall__Inputs {
  _call: ExtractERC721FromCall;

  constructor(call: ExtractERC721FromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get to(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class ExtractERC721FromCall__Outputs {
  _call: ExtractERC721FromCall;

  constructor(call: ExtractERC721FromCall) {
    this._call = call;
  }

  get newId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get metaTransactionContract(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get assetAdmin(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get bouncerAdmin(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
